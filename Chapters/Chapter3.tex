\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo se describe la solución de software completa, detallando la arquitectura y la implementación técnica. La solución se centra en la integración de la simulación hidráulica y la inteligencia artificial para crear un gemelo digital híbrido. Finalmente, se explica cómo este gemelo se conecta a través de una interfaz de programación (API) con el motor de optimización para automatizar el despacho de riego.

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}



\section{Arquitectura general del software}



\label{sec:arquitectura_general}

El diseño del sistema de riego se basa en una arquitectura de cuatro capas: la capa física, la de control y adquisición, la de gestión y optimización, y la de presentación (ver figura \ref{fig:diagrama_capas}). Este trabajo se enfoca exclusivamente en la capa de gestión y optimización, que es responsable de transformar los datos históricos y de telemetría en un plan de despacho de riego óptimo.

El software se implementó bajo una arquitectura de microservicios \citep{Newman2015_Microservices}. Esto garantiza la separación de responsabilidades y la escalabilidad horizontal de los dos componentes centrales: el entrenamiento continuo del modelo predictivo y su consumo operativo.

El diseño se basa en dos subsistemas, encapsulados en contenedores Docker para asegurar un entorno de ejecución aislado y consistente: el subsistema de entrenamiento y ciclo de vida (MLOps) y el subsistema de optimización y servicio. La vinculación entre ellos se establece a través de un registro central de modelos, lo que permite al motor de decisión consumir siempre la versión más precisa del gemelo digital híbrido, mientras el \textit{pipeline} de MLOps opera de forma asíncrona.


\subsection{Subsistema de entrenamiento y ciclo de vida (MLOps)}
\label{sec:subsistema_mlops}

Este subsistema tiene como objetivo principal la sostenibilidad de la precisión del modelo predictivo. Mantiene el gemelo digital híbrido actualizado al ejecutar un ciclo de vida automatizado que mitiga el (\textit{model drift}) \citep{Schlachter2020_HybridModel}. Este flujo de trabajo, fundamental para un entorno de producción, está orquestado por \textit{pipelines} de Apache Airflow \citep{AirflowApache_Orchestration}.

La arquitectura comprende un \textit{stack} de infraestructura para el manejo de los artefactos y la trazabilidad de los experimentos:
\begin{itemize}
    \item Data Lake (MinIO): repositorio central de objetos que almacena los datos de telemetría históricos y los datasets limpios, actuando como la fuente única de verdad para el entrenamiento.
    \item Registro de Artefactos (MLflow): administra el ciclo de vida completo del modelo \citep{MLflowDatabricks}. Registra los hiperparámetros, métricas y los artefactos binarios (el modelo y los transformadores de características) que son promovidos a producción para su consumo por el servicio de inferencia.
    \item Orquestación (PostgreSQL/Airflow): la base de datos PostgreSQL gestiona los metadatos y el estado de los \textit{pipelines} de Airflow, asegurando la fiabilidad y reintentos del proceso de integración y despliegue continuo (CI/CD) \citep{Holo2020_MLOps}.
\end{itemize}

El \textit{pipeline} de entrenamiento se estructura en una secuencia de módulos lógicos de procesamiento de datos:

\begin{enumerate}
    \item Módulo de ingesta y consolidación: responsable de la lectura y unificación de los datos de telemetría histórica del campo desde el Data Lake.
    \item Módulo de limpieza: filtra los registros inconsistentes y asegura la calidad del \textit{dataset}.
    \item Módulo de ingeniería de características: genera las variables sintéticas necesarias para el modelo de corrección de residuales, como el número de actuadores activos.
    \item Módulo de entrenamiento: ejecuta el entrenamiento. Si el nuevo modelo supera los umbrales de desempeño, es promovido al alias de \texttt{production} en el registro de modelos, lo que completa el ciclo de integración y despliegue continuo (CI/CD) \citep{Holo2020_MLOps}.
\end{enumerate}


\subsection{Subsistema de optimización y servicio}
\label{sec:subsistema_optimizacion}

Este subsistema constituye el corazón operativo del sistema, implementando el motor de decisión encargado de resolver el problema de programación matemática. Su arquitectura es diseñada específicamente para superar el cuello de botella computacional que representa la simulación hidráulica secuencial. Para ello, se diferencian dos componentes acoplados mediante una estrategia de escalabilidad horizontal.

\begin{enumerate}
    \item Capa de servicio de inferencia distribuida (\textit{Snapshot API}):
    el diseño de arquitectura resuelve el desafío de rendimiento mediante la implementación de un clúster de microservicios de simulación. Cada unidad es un servicio RESTful asíncrono desarrollado con FastAPI \citep{FastAPI_Documentation}, diseñado para ser ligero y sin estado (\textit{stateless}) en cuanto a la petición, pero manteniendo en memoria el estado completo del gemelo digital híbrido (modelo físico WNTR más el modelo corrector de IA).
    
    Para lograr la aceleración requerida por el algoritmo genético, se implementa una estrategia de orquestación mediante Docker Swarm \citep{DockerSwarm_Documentation}. Esta tecnología permite instanciar múltiples réplicas del microservicio de simulación, distribuyéndolas dinámicamente a través de los nodos físicos disponibles en el clúster. El tráfico entrante es gestionado por una instancia de NGINX \citep{NGINX_Documentation}, que actúa como balanceador de carga, distribuyendo las miles de peticiones de evaluación generadas por el optimizador entre las distintas réplicas activas. Esta arquitectura permite paralelizar masivamente el cálculo de la función de costo, reduciendo el tiempo de búsqueda de forma lineal con respecto a la cantidad de recursos de hardware agregados.

    \item Motor de optimización:
    el motor implementa la lógica metaheurística del AG. A diferencia de una implementación secuencial tradicional, este módulo dispone de una interfaz cliente asíncrona que aprovecha la concurrencia (\textit{multithreading}) para enviar lotes de solicitudes de simulación simultáneas.
    
    Durante cada generación del AG, la evaluación de la aptitud de la población no se realiza individuo por individuo, sino que se distribuye a través de la red hacia el balanceador de carga. Esto permite que múltiples planes de riego sean simulados al mismo tiempo por las distintas instancias del servicio de inferencia, lo que permite aprovechar al máximo la capacidad de cómputo instalada y cumplir con los estrictos requisitos temporales.
\end{enumerate}


\begin{figure}[ht]
    \centering
	\includegraphics[width=\textwidth]{Figures/despacho_v1.pdf}
    \caption{Diagrama de capas del sistema de riego, donde el foco del trabajo es la capa de gestión y optimización.}
    \label{fig:diagrama_capas}
\end{figure}

\pagebreak

%----------------------------------------------------------------------------------------
%	SECTION 3.2
%----------------------------------------------------------------------------------------
\section{Implementación del gemelo digital híbrido}
\label{sec:implementacion_gemelo}

El gemelo digital se desarrolló bajo el paradigma de caja gris, fusionando un modelo hidráulico de primeros principios con un componente de aprendizaje profundo (\textit{deep learning}). Este último tiene la función específica de predecir y corregir los errores residuales de la simulación física. Para asegurar la vigencia del sistema, la solución se integró en un ciclo de vida automatizado que ejecuta entrenamientos periódicos del modelo ante la llegada de nuevos datos de campo.

La figura \ref{fig:gemelo_hibrido} presenta el esquema conceptual del sistema implementado, ilustrando el flujo de información desde la ingesta de datos de campo hasta la generación del estado corregido del sistema.

A continuación, se detalla la ingeniería aplicada en cada uno de sus componentes constitutivos.

\subsection{Construcción y parametrización del modelo físico}
\label{subsec:modelo_fisico}

El componente físico ($f_{fisico}$) se implementó utilizando la biblioteca \textit{Water Network Tool for Resilience} (WNTR) \citep{WNTRShaw2018}. Se optó por definir la topología de la red mediante funciones de Python en lugar de utilizar archivos de configuración estáticos. Esta estrategia permite modificar las propiedades de la infraestructura, como la curva de la bomba o la longitud de los laterales, alterando directamente las variables del código fuente, lo cual elimina la necesidad de regenerar archivos externos ante cada cambio en los parámetros de diseño.

La red se modeló representando explícitamente los componentes hidráulicos principales: la fuente de agua subterránea, el grupo de bombeo, el cabezal de filtrado y la red de distribución. Para garantizar la fidelidad de la simulación base, se configuraron los siguientes parámetros constitutivos extraídos de las especificaciones técnicas:

\begin{itemize}
    \item Modelo de fricción en tuberías: para la cuantificación de las pérdidas por fricción, se seleccionó la ecuación de Hazen-Williams. Se estableció un coeficiente de rugosidad adimensional $C=130.0$, aplicado de manera uniforme a los tramos de conducción principal y a los laterales de riego, valor que corresponde a tuberías plásticas con un desgaste operativo estándar.

    \item Caracterización de la bomba: el comportamiento del sistema de bombeo se representó mediante la curva característica de altura manométrica-caudal ($H-Q$). Esta curva se definió mediante la interpolación de 16 puntos operativos, abarcando el rango completo desde la presión a válvula cerrada ($H \approx 124$ m) hasta el caudal máximo.

    \item Comportamiento de los emisores: se configuró un exponente de flujo $\gamma = 0.46$, propio del régimen turbulento en los emisores instalados, y un coeficiente de descarga base ajustado a las especificaciones del fabricante.
\end{itemize}

Sin embargo, la simulación individual de los miles de goteros presentes en el campo generaba una carga computacional incompatible con los tiempos de respuesta requeridos. Para solucionar este desafío, se implementó un algoritmo de agregación espacial en la función de generación de laterales. Este algoritmo discretiza cada lateral de riego en un número fijo de segmentos. En lugar de instanciar cada emisor físico, se asigna un emisor equivalente a cada nodo de discretización, cuyo coeficiente de descarga se calcula como la suma aritmética de los coeficientes de los goteros reales contenidos en dicho segmento. Esta técnica reduce la dimensión de la matriz hidráulica que resuelve el motor WNTR, disminuyendo el tiempo de ejecución de la simulación de segundos a milisegundos.

Finalmente, la ejecución del modelo se configuró bajo el esquema de análisis dirigido por presión (PDA). A diferencia del modelo de demanda base (DDA), que fija el consumo independientemente del estado hidráulico, el esquema PDA calcula el caudal real entregado por los emisores como una función de la presión nodal instantánea.

\subsection{Ingeniería de datos y modelo de corrección}
\label{subsec:componente_corrector}

El componente de inteligencia artificial ($f_{AI}$) se diseñó con el objetivo específico de predecir el residual ($R$), definido como la diferencia entre el caudal real medido y la estimación teórica del modelo físico base. Para garantizar la calidad de la información de entrenamiento, el flujo de datos inicia con una etapa de limpieza rigurosa en la que se aplican filtros para eliminar registros inconsistentes, tales como instantes donde los datos reportan caudales positivos y válvulas cerradas. 

Sobre el conjunto de datos depurado, se ejecutó un proceso de ingeniería de características orientado a capturar las no linealidades del sistema hidráulico. A las variables base disponibles, la presión real medida en cabecera y el caudal simulado por el modelo físico, se sumaron variables sintéticas. Se generó el conteo total de válvulas activas (\texttt{valve\_count}) mediante la suma de los estados binarios de los sectores, y se creó un término de interacción física (\texttt{presion\_x\_valve\_count}) multiplicando la presión real por dicho conteo. Esta última variable actúa como un estimador de la impedancia hidráulica total del sistema, facilitando a la red neuronal la distinción entre variaciones de caudal debidas a la operación de la bomba y aquellas causadas por apertura y cierre de válvulas.

Previo al entrenamiento, se aplicó una estrategia de saneamiento estadístico sobre la variable objetivo (el residual), eliminando valores atípicos (\textit{outliers}) mediante el método del rango intercuartílico (IQR). Posteriormente, los datos se dividieron cronológicamente en subconjuntos de entrenamiento, validación y prueba, y se normalizaron las características numéricas utilizando un escalador estándar (StandardScaler). Es fundamental destacar que el escalador se ajusta exclusivamente con los parámetros estadísticos del conjunto de entrenamiento y luego se utiliza para transformar los conjuntos restantes, evitando así la fuga de información estadística (\textit{data leakage}) hacia los datos de validación.

Finalmente, el modelo de corrección se implementó utilizando un MLP desarrollado con la biblioteca PyTorch \citep{Paszke2019_PyTorch}. La arquitectura de la red, compuesta por capas densas con funciones de activación no lineales, se optimizó para realizar la regresión del valor residual a partir del vector de características procesado. El proceso de entrenamiento minimiza la función de pérdida de error MSE e integra un mecanismo de parada temprana (\textit{early stopping}) que monitorea el desempeño en el conjunto de validación, previniendo el sobreajuste y garantizando la robustez del modelo ante nuevas condiciones operativas.

\pagebreak

\subsection{Ciclo de vida y gestión de artefactos (MLOps)}
\label{subsec:ciclo_vida_mlops}

La implementación del gemelo digital trasciende el código fuente. Se monta sobre una infraestructura de operaciones de aprendizaje automático (MLOps) orquestada por Apache Airflow \citep{AirflowApache_Orchestration}. Este sistema gestiona el flujo de datos desde su ingesta hasta el despliegue, estructurado en las siguientes etapas:

\begin{itemize}
    \item Gestión de datos en capas: se utiliza un Data Lake basado en MinIO para almacenar los datos en tres estadios de refinamiento: crudos (\textit{raw}), intermedios (\textit{intermediate}) y procesados (\textit{primary}). Esta arquitectura de capas permite la trazabilidad y la reproducibilidad de cualquier versión del \textit{dataset}.
    
    \item Registro de experimentos: cada ejecución del \textit{pipeline} de entrenamiento registra automáticamente las métricas de desempeño (RMSE, $R^2$) y los artefactos resultantes (el modelo serializado y los objetos escaladores) en un servidor de MLflow \citep{MLflowDatabricks}. Esto permite analizar la evolución del desempeño del modelo a lo largo del tiempo.
    
    \item Validación y promoción automática: el \textit{pipeline} incluye una etapa de decisión autónoma. Tras el entrenamiento, el sistema evalúa el nuevo modelo frente a un conjunto de prueba. Solo si el nuevo modelo supera en precisión al vigente (reducción del RMSE), se promueve automáticamente mediante el etiquetado de alias en el registro, quedando disponible inmediatamente para el servicio de inferencia.
\end{itemize}

\subsection{Orquestación y ejecución en el servicio de inferencia}
\label{subsec:orquestacion_inferencia}

El servicio de inferencia (\textit{Snapshot API}) es el componente que ejecuta el gemelo digital híbrido. Su función principal es coordinar la comunicación entre los modelos almacenados y las solicitudes de simulación que envía el optimizador. El código se diseñó para cargar todo lo necesario en la memoria RAM al iniciar el servidor, evitando así lecturas lentas de disco durante la operación.

Al arrancar, el servicio se conecta al registro de MLflow y descarga la versión del modelo de inteligencia artificial marcada como \textit{production}. También inicializa el modelo físico WNTR. Esta preparación previa permite que el sistema responda a las peticiones de simulación mas rápidamente.

Cada vez que el optimizador solicita evaluar un plan de riego, el servicio ejecuta los siguientes pasos de forma secuencial:

\begin{enumerate}
    \item Cálculo físico base: el servicio ejecuta primero el simulador WNTR. Este paso entrega un valor de caudal y las presiones para la configuración de válvulas solicitada.

    \item Preparación de datos para la IA: el sistema toma los resultados físicos y calcula las variables adicionales que necesita la red neuronal, como la cantidad de válvulas abiertas y su interacción con la presión. Luego ajusta la escala de estos valores utilizando el artefacto guardado en MLFlow durante el entrenamiento.

    \item Corrección del error: la red neuronal recibe los datos preparados y predice el error residual del modelo físico. El sistema suma este error a la predicción física inicial para obtener el caudal final corregido.

    \item Respuesta: con el caudal corregido, el sistema estima cómo se distribuye el caudal residual entre los sectores activos y calcula cuánto desciende el nivel del acuífero usando un modelo de pozo específico. Estos valores finales se envían de vuelta al optimizador para que evalúe si el plan es bueno o malo.
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{Figures/gemelo_hibrido.pdf}
    \caption{Esquema del gemelo digital híbrido: integración del pipeline de entrenamiento (MLOps), el modelo físico WNTR y el corrector de IA en el servicio de inferencia.}
    \label{fig:gemelo_hibrido}
\end{figure}




\pagebreak

\section{Implementación del optimizador de despacho (GA)}
\label{sec:implementacion_ga}

La implementación del motor de optimización representa el componente inteligente de decisión del sistema. Su diseño responde a la naturaleza combinatoria y no lineal del problema de programación de riego, donde los métodos tradicionales de programación lineal mixta-entera resultan computacionalmente inviables debido a la complejidad de las funciones hidráulicas subyacentes.

Se desarrolló un AG personalizado en el lenguaje Python, estructurado bajo el paradigma de programación orientada a objetos para garantizar la modularidad y el mantenimiento del código. Este motor integra lógica específica del dominio hidráulico directamente en la estructura de datos del cromosoma y en el ciclo de evaluación de aptitud. Esta integración permite reducir el espacio de búsqueda y acelerar la convergencia hacia soluciones factibles.

La figura \ref{fig:flujo_ag} ilustra el flujo de control del sistema implementado, destacando la interacción con el clúster de simulación distribuida.

\begin{figure}[ht]
    \centering
     \includegraphics[width=\textwidth]{Figures/ag.pdf}
    \caption{Diagrama de flujo del Algoritmo Genético Distribuido, destacando la etapa de evaluación paralela y el operador de reparación de restricciones físicas.}
    \label{fig:flujo_ag}
\end{figure}

\subsection{Representación matricial y codificación}
\label{subsec:codificacion}

El diseño de la estructura de datos para representar una solución candidata es fundamental para el rendimiento del algoritmo. Se optó por una codificación por valor binario (\textit{value encoding}), implementada no como una lista lineal, sino como una matriz bidimensional utilizando tipos de datos de bajo nivel (\texttt{uint8}) de la biblioteca NumPy.

La matriz $C$, de dimensiones $N_{actuadores} \times N_{intervalos}$, modela el estado de todos los elementos activos del sistema:

\begin{itemize}
    \item Dimensión espacial (filas): la primera fila (índice 0) representa el estado de la bomba principal. Las filas subsiguientes (índices 1 a $N$) corresponden a las válvulas electro-comandadas de cada sector de riego.
    \item Dimensión temporal (columnas: se define dinámicamente en función del horizonte de predicción. Para un horizonte típico de 24 horas con una resolución de 30 minutos, la matriz tiene 48 columnas.
\end{itemize}

Esta representación matricial permite aplicar operaciones vectorizadas para el cálculo de costos y la manipulación genética. El código \ref{cod:create_individual} muestra la implementación de la función generadora, que instancia el cromosoma completo en una sola operación optimizada, garantizando una sobrecarga de memoria mínima incluso para poblaciones grandes.

\begin{lstlisting}[label=cod:create_individual, caption=Generación vectorizada del cromosoma como matriz binaria., language=Python]
def _create_individual(self) -> np.ndarray:
    """
    Genera una matriz de (N_actuadores x N_intervalos)
    con valores 0 o 1 (enteros de 8 bits).
    """
    return np.random.randint(0, 2, 
                             size=(self.n_actuadores, self.n_intervals), 
                             dtype=np.uint8)
\end{lstlisting}

\subsection{Manejo de restricciones y reparación}
\label{subsec:reparacion}

El espacio de búsqueda de cromosomas binarios aleatorios contiene una vasta cantidad de soluciones que son físicamente incoherentes. El caso más crítico es la configuración donde una o más válvulas de sector están abiertas ($v_{i,t}=1$) mientras la bomba principal está apagada ($v_{0,t}=0$). Evaluar estos individuos sería un desperdicio de recursos computacionales, ya que el simulador hidráulico arrojaría caudal cero o errores de convergencia numérica.

Para abordar esto, se implementó un mecanismo de reparación dentro del motor del AG. Este operador actúa como un filtro de consistencia hidráulica que se aplica inmediatamente después de la inicialización y tras cada operación de cruce o mutación.

La lógica aplica una operación de máscara booleana donde el estado de cada válvula en el tiempo $t$ se multiplica por el estado de la bomba en ese mismo instante. Matemáticamente, esto asegura la condición:
\begin{equation}
    v_{i,t} \leftarrow v_{i,t} \land v_{0,t} \quad \forall i > 0
\end{equation}
Esta técnica transforma el problema de una optimización con restricciones duras a una optimización sobre un subespacio factible, guiando la búsqueda hacia regiones productivas desde la primera generación.

\subsection{Arquitectura de evaluación distribuida y cliente asíncrono}
\label{subsec:evaluacion_distribuida}

Uno de los desafíos técnicos más significativos en la optimización de sistemas físicos es el costo temporal de la función de evaluación (\textit{fitness function}). En este sistema, evaluar un plan de riego implica simular su comportamiento hidráulico completo para determinar el caudal entregado y el consumo energético.

Para dimensionar la necesidad de una arquitectura escalable, consideremos un escenario estándar con una población de 50 individuos y un horizonte de 24 horas (48 intervalos). El número total de simulaciones hidráulicas ($N_{sims}$) requeridas por generación se calcula según ecuación \ref{num_sims}.
\begin{equation}\label{num_sims}
    N_{sims} = 50 \times 48 = 2.400 \text{ simulaciones/generación}
\end{equation}
Si cada simulación tomara apenas 0.1 segundos, una ejecución secuencial demoraría 4 minutos por generación, resultando en horas de cómputo para converger.

Para resolver este cuello de botella, se diseñó una arquitectura de evaluación distribuida implementada en la clase \texttt{DigitalTwinClient}. Esta clase actúa como un proxy inteligente que desacopla el algoritmo genético del motor de simulación, gestionando la complejidad de la comunicación con el clúster de microservicios. Para ello, el cliente implementa un patrón de concurrencia a dos niveles para maximizar el rendimiento (\textit{throughput}):

\begin{enumerate}
    \item Sesiones persistentes: se instancia un objeto \texttt{requests.Session} que mantiene un \textit{pool} de conexiones TCP abiertas (\textit{Keep-Alive}) hacia el balanceador de carga. Esto elimina la latencia asociada al \textit{handshake} TCP/IP en cada una de las miles de peticiones enviadas.
    
    \item Paralelismo: el cliente descompone la matriz del cromosoma en $N$ tareas de simulación independientes, correspondientes a las columnas (intervalos de tiempo) donde la bomba está activa. Utilizando la biblioteca \texttt{concurrent}, estas tareas se envían de forma asíncrona a un ThreadPoolExecutor.
\end{enumerate}

Esta estrategia permite saturar la capacidad de procesamiento del clúster Docker Swarm, distribuyendo la carga de trabajo entre todos los núcleos disponibles en la infraestructura física. El cliente es responsable de reensamblar los resultados parciales asíncronos en una estructura de datos coherente para el cálculo del costo final.

\subsection{Diseño de la función de aptitud}
\label{subsec:funcion_aptitud}

La función de aptitud es el componente que guía la búsqueda hacia soluciones que equilibren la eficiencia operativa con los objetivos requeridos por el agrónomo. El valor de aptitud para un individuo se calcula integrando los resultados parciales obtenidos de las simulaciones distribuidas.

El método de evaluación agrega los volúmenes de agua simulados para cada sector y calcula una suma ponderada del costo energético y las penalizaciones por desvíos hídricos. El diseño prioriza una penalización cuadrática ($L2$) sobre la diferencia entre el volumen de agua entregado y el objetivo ($V_{target}$). 


\subsection{Operadores evolutivos implementados}
\label{subsec:operadores_evolutivos}

La mecánica de evolución de la población se rige por tres operadores estocásticos seleccionados específicamente para trabajar sobre la representación matricial binaria del problema. A continuación, se detalla la implementación lógica y el código fuente de cada uno.

\subsubsection{Selección por torneo}

Para seleccionar los padres de la siguiente generación, se implementó el método de selección por torneo. Como se observa en el código \ref{cod:selection}, este operador selecciona aleatoriamente un subconjunto de individuos de la población (definido por \texttt{tournament\_size}) y determina el ganador basándose en el valor mínimo de aptitud. Esta implementación vectorizada utiliza NumPy para realizar el muestreo aleatorio y la comparación de índices, lo que resulta computacionalmente más eficiente que ordenar la población completa en cada generación.

\begin{lstlisting}[label=cod:selection, caption=Implementación de la selección por torneo., language=Python]
def _selection_tournament(self, fitness_scores: np.ndarray) -> np.ndarray:
    """
    Selecciona un individuo usando seleccion por torneo.
    """
    # Elegir 'tournament_size' individuos al azar
    contenders_idx = np.random.randint(0, self.pop_size, 
                                     self.tournament_size)
    
    # Obtener sus puntuaciones de aptitud
    contender_fitness = fitness_scores[contenders_idx]
    
    # El ganador es el que tiene la aptitud MAS BAJA (menor costo)
    winner_idx_in_contenders = np.argmin(contender_fitness)
    winner_global_idx = contenders_idx[winner_idx_in_contenders]
    
    return self.population[winner_global_idx]
\end{lstlisting}

\subsubsection{Cruce uniforme matricial}

Dada la estructura matricial del cromosoma, donde no existe una dependencia espacial fuerte entre intervalos de tiempo distantes, se optó por el cruce uniforme. El código \ref{cod:crossover} detalla la lógica de este operador. Se genera una máscara aleatoria de bits con las mismas dimensiones que el cromosoma. La descendencia se construye aplicando operaciones lógicas a nivel de bits (\textit{bitwise operations}). Esta técnica asegura una mezcla profunda del material genético, permitiendo recombinar patrones de riego exitosos independientemente de su ubicación temporal.

\begin{lstlisting}[label=cod:crossover, caption=Implementación del cruce uniforme con operaciones de máscara., language=Python]
def _crossover_uniform(self, parent1: np.ndarray, 
                       parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    child1, child2 = parent1.copy(), parent2.copy()
    
    if random.random() < self.crossover_rate:
        # 1. Crear mascara aleatoria de 0s y 1s
        mask = np.random.randint(0, 2, size=parent1.shape, dtype=np.uint8)
        
        # 2. Crear la mascara inversa
        mask_inv = 1 - mask
        
        # 3. Aplicar mascaras para crear los hijos
        child1 = (parent1 * mask) | (parent2 * mask_inv)
        child2 = (parent2 * mask) | (parent1 * mask_inv)
        
    return child1, child2
\end{lstlisting}

\subsubsection{Mutación bit-flip}

Para mantener la diversidad genética y evitar el estancamiento en óptimos locales, se aplicó un operador de mutación por inversión de bit. El código \ref{cod:mutation} muestra cómo el algoritmo recorre la matriz del cromosoma y, sujeto a una baja probabilidad de mutación ($P_m$), invierte el estado binario del gen ($1-x$). Es importante notar que, tras este operador, el individuo resultante es procesado nuevamente por la función de reparación descrita en la sección \ref{subsec:reparacion} para garantizar la coherencia física del sistema.

\begin{lstlisting}[label=cod:mutation, caption=Lógica de mutación bit-flip., language=Python]
def _mutation_bit_flip(self, chromosome: np.ndarray) -> np.ndarray:
    mutated_chromosome = chromosome.copy()
    for i in range(self.n_actuadores):
        for t in range(self.n_intervals):
            if random.random() < self.mutation_rate:
                # Inversion de bit: 1 -> 0 o 0 -> 1
                mutated_chromosome[i, t] = 1 - mutated_chromosome[i, t]
    return mutated_chromosome
\end{lstlisting}

\subsubsection{Estrategia de elitismo}

Finalmente, para asegurar la convergencia monótona del algoritmo y evitar la pérdida de las mejores soluciones encontradas debido a la estocasticidad de los operadores genéticos, se implementó una estrategia de elitismo. En cada generación, antes de aplicar la selección y el cruce, el algoritmo identifica los $N$ mejores individuos de la población actual (típicamente los 2 mejores) y los copia directamente a la siguiente generación sin modificaciones. Esto garantiza que la calidad de la mejor solución nunca disminuya a lo largo del proceso evolutivo.

\pagebreak

%----------------------------------------------------------------------------------------
%	SECTION 3.4
%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
%	SECTION 3.4
%----------------------------------------------------------------------------------------
\section{Implementación de funciones de costo y penalizaciones}
\label{sec:implementacion_costo}

La función de costo, o función de aptitud, representa la traducción matemática de los objetivos del negocio y las restricciones físicas del sistema. Su implementación es crítica, ya que define el gradiente de búsqueda que guía al algoritmo genético a través del vasto espacio de soluciones posibles. En este trabajo, se implementó una función de evaluación compuesta que agrega múltiples objetivos competitivos, eficiencia energética, cumplimiento agronómico y sostenibilidad, en un único valor escalar.

La lógica de evaluación reside en el método \texttt{evaluate\_schedule} de la clase cliente del gemelo digital. Este método actúa como un agregador de resultados, procesando los datos devueltos por el clúster de inferencia para cuantificar el desempeño global del plan de riego.

\subsection{Costo base de eficiencia operativa}

El primer componente de la función objetivo busca minimizar el uso de recursos operativos. Dado que el sistema es alimentado por energía solar fotovoltaica, el costo no es necesariamente monetario, sino temporal y de desgaste de equipos. Se definió la eficiencia en términos de tiempo de bombeo acumulado, calculada según la ecuación \ref{eq:costo_eficiencia}:

\begin{equation}\label{eq:costo_eficiencia}
    C_{eficiencia} = \sum_{t=1}^{T} v_{0,t} \cdot \Delta t
\end{equation}

donde $v_{0,t}$ representa el estado binario de la bomba en el intervalo $t$ (1 si está encendida, 0 si está apagada), y $\Delta t$ corresponde a la duración del intervalo de tiempo discretizado (en horas).

Esta formulación incentiva al algoritmo a encontrar la solución más compacta posible, aquella que entrega el volumen de agua requerido en la menor cantidad de horas de operación, lo cual maximiza la vida útil del equipo de bombeo y libera ventanas de tiempo para mantenimiento o contingencias.

\subsection{Penalización agronómica cuadrática}

El objetivo primordial del sistema es satisfacer la demanda hídrica del cultivo. Sin embargo, en un escenario de recursos limitados, es común que no se pueda satisfacer la totalidad de la demanda de todos los sectores simultáneamente. El desafío de implementación consistió en definir cómo penalizar estos déficits para promover una distribución justa del agua.

Se descartó el uso de una penalización lineal o diferencia absoluta en favor de una penalización cuadrática (norma L2), definida en la ecuación \ref{eq:penalizacion_volumen}:

\begin{equation}\label{eq:penalizacion_volumen}
    P_{volumen} = \sum_{i=1}^{N} (V_{sim, i} - V_{target, i})^2
\end{equation}

donde $N$ es el número total de sectores de riego, $V_{sim, i}$ es el volumen acumulado simulado para el sector $i$, y $V_{target, i}$ es el volumen objetivo definido por el agrónomo para dicho sector.

El código \ref{cod:fitness_calc} presenta la implementación de esta lógica, donde se observa cómo el algoritmo itera sobre los resultados de volumen acumulado por sector y eleva al cuadrado la diferencia respecto al objetivo antes de sumarla al costo total.

\begin{lstlisting}[label=cod:fitness_calc, caption=Cálculo de la penalización hídrica cuadrática., language=Python]
# Logica de penalizacion L2 (Cuadratica)
penalizacion_hidrica_cuadratica = 0.0
desviacion_hidrica_absoluta_m3 = 0.0

for sector_name, target_m3 in self.targets_m3.items():
    # Obtener el volumen total simulado para el sector
    achieved_m3 = total_volume_per_sector.get(sector_name, 0.0)
    
    # Calcular el desvio
    desviacion = (achieved_m3 - target_m3)
    
    # Penalizacion cuadratica: castiga desproporcionadamente
    # los grandes desvios
    penalizacion_hidrica_cuadratica += (desviacion ** 2)
    
    # Metrica auxiliar para reporte
    desviacion_hidrica_absoluta_m3 += abs(desviacion)

# Calculo final de aptitud
penalizacion_total = self.w_hidrico_quad * penalizacion_hidrica_cuadratica
aptitud_total = costo_eficiencia + penalizacion_total
\end{lstlisting}

Esta decisión de diseño tiene un impacto profundo en el comportamiento del optimizador. Al elevar el error al cuadrado, un déficit grande en un solo sector se penaliza mucho más severamente que varios déficits pequeños distribuidos en varios sectores. En consecuencia, el algoritmo prioriza naturalmente soluciones que equilibran el riego entre parcelas, evitando sacrificar completamente un sector para beneficiar a otro, lo cual se alinea con las mejores prácticas agronómicas para mantener la uniformidad del cultivo.

\subsection{Manejo de restricciones físicas y ambientales}

Además de los objetivos de eficiencia y volumen, el sistema debe respetar restricciones operativas estrictas. La implementación aborda estas limitaciones mediante el método de funciones de penalización, transformando violaciones de límites físicos en costos adicionales que degradan la aptitud del individuo.

En primer lugar, la operación de la bomba está condicionada por la curva de generación solar. El servicio de inferencia verifica en cada intervalo si la potencia requerida por el punto de operación hidráulico excede la potencia disponible pronosticada. Si se detecta una violación o déficit de potencia, el simulador retorna un estado de fallo. En el lado del cliente, se implementó una lógica que asigna un valor de aptitud infinito a ese intervalo ante un fallo energético. Esto actúa como una barrera suave que empuja rápidamente a la población del algoritmo genético lejos de las configuraciones que intentan operar la bomba fuera de las horas de radiación solar efectiva.

Simultáneamente, para proteger el recurso hídrico subterráneo, se estableció un límite máximo de descenso del nivel dinámico del pozo. El gemelo digital estima este descenso en función del caudal total extraído en cada instante. La función de costo implementa una penalización dinámica para esta variable, expresada en la ecuación \ref{eq:penalizacion_acuifero}:

\begin{equation}\label{eq:penalizacion_acuifero}
    P_{acuifero} = \sum_{t=1}^{T} \max(0, N_{min} - N_{sim, t}) \times w_{sostenibilidad}
\end{equation}

donde $N_{min}$ es el nivel mínimo de seguridad del acuífero (profundidad máxima permitida), $N_{sim, t}$ es el nivel dinámico simulado en el tiempo $t$, y $w_{sostenibilidad}$ es un factor de ponderación que ajusta la severidad de la penalización.

Esta implementación permite que el algoritmo explore soluciones cercanas al límite operativo del pozo, lo que maximiza la extracción permitida pero crea un fuerte gradiente de rechazo en cuanto se compromete la seguridad del acuífero.

\subsection{Agregación final y ponderación}

El valor final de aptitud, o \textit{fitness}, devuelto al motor genético es la suma ponderada de todos los componentes descritos, como muestra la ecuación \ref{eq:fitness_total}:

\begin{equation}\label{eq:fitness_total}
    Fitness = C_{eficiencia} + (w_q \cdot P_{volumen}) + (w_s \cdot P_{acuifero}) + (w_p \cdot P_{potencia})
\end{equation}

donde $w_q$, $w_s$ y $w_p$ son los coeficientes de ponderación para los objetivos de volumen, sostenibilidad del acuífero y cumplimiento de potencia, respectivamente.

En la implementación actual, se asignó un peso preponderante a la penalización por volumen ($w_q$), estableciendo que la satisfacción de la demanda de riego es la prioridad jerárquica superior, seguida por la sostenibilidad del acuífero y, finalmente, la eficiencia operativa.

Finalmente, cabe destacar que la arquitectura del software expone estos parámetros como variables de configuración externa. Tanto los pesos de la función de costo, como los volúmenes objetivo por sector, el horizonte de planificación y la discretización temporal, constituyen las entradas principales del sistema de gestión. Estos valores están diseñados para ser definidos por el usuario a través de una interfaz de consola o gráfica, lo que otorga al ingeniero agrónomo el control total para ajustar la estrategia de optimización y ejecutar el plan de riego según las necesidades específicas del cultivo y las condiciones operativas del momento.